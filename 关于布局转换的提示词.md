核心思想：从“绝对坐标”思维转向“相对关系”思维

所有布局分析的根本，都是将图层的绝对 (x, y) 坐标，转换成图层与图层之间、图层与父容器之间的相对关系，如：对齐、分布、间距。

---

策略一：聚类分析 —— 识别“行”与“列”

这是布局分析的第一步。拿到一个父容器里散落的几十个图层，你首先要把它们组织成有意义的结构。

1.  识别“行” (Vertical Clustering):

    - 方法：将一个容器内的所有子图层，首先按照它们的 y 坐标进行排序。
    - 逻辑：遍历排序后的图层，如果两个图层的 y 坐标非常接近（例如，在 3px 的误差范围内），我们就认为它们属于同一行。
    - 产出：通过这个过程，你可以得到一个“行的列表”，每一行又包含着属于该行的图层。例如 [[layerA, layerB], [layerC, layerD, layerE]]。

2.  识别“列” (Horizontal Analysis):
    - 方法：在已经识别出的每一“行”内部，再将图层按 x 坐标排序。
    - 逻辑：这样处理后，你就得到了一个清晰的二维结构。例如，上面例子中的 layerA 和 layerC 就可能在视觉上构成一列。

---

策略二：布局模式匹配 —— 推断 Grid 与 Flex

当你有了二维的行列结构后，就可以开始匹配布局模式了。优先级是 Grid > Flex。

1.  何时推断为 Grid 布局？

    - 条件：当你的聚类分析产生了多行，并且每一行的元素数量都相同时（例如 3x2 的卡片列表），这是一个非常强烈的 Grid 信号。
    - 如何提取参数：
      - grid-template-columns: repeat(每行的元素数量, 1fr) 是一个很好的起点。
      - gap: 这是关键。你需要计算元素间的间距。
        - 水平间距 (column-gap): 后一个元素的 x - (前一个元素的 x + 前一个元素的 width)。
        - 垂直间距 (row-gap): 下一行第一个元素的 y - (上一行第一个元素的 y + 上一行第一个元素的高度)。
        - 计算出所有间距后，可以取一个平均值或中位数作为最终的 gap 值。
    - DSL 输出: 在你的 DSL 中，可以这样描述：{ "layout": "grid", "columns": 3, "gap": 16 }。

2.  何时推断为 Flex 布局？
    - 条件 (Flex-Row): 如果聚类分析后，只产生了唯一的一行，里面有多个元素（例如顶部的导航栏菜单），这几乎肯定是 Flex 的行布局 (flex-direction: row)。
    - 条件 (Flex-Column): 如果产生了多行，但每一行都只有一个元素，并且它们的 x 坐标非常接近（即垂直对齐），这很可能是 Flex 的列布局 (flex-direction: column)。
    - 如何提取参数:
      - gap: 计算方式与 Grid 类似，只是只用计算单个方向的。
      - justify-content / align-items: 这个更进阶一些。你可以通过判断子元素们整体在父容器中的位置来推断。例如，如果一组子元素左右都有很大的空白，可能 justify-content 是 center 或
        space-between。
    - DSL 输出: { "layout": "flex", "direction": "row", "justify": "center", "spacing": 12 }。

---

策略三：优雅降级 —— 回退到绝对定位

你必须承认，不是所有的设计都能完美地套入 Grid 或 Flex 模型，尤其是复杂的背景、插画、或不规则的设计。

- 条件：当上述所有策略都匹配失败时（例如，行内元素数量不一、间距毫无规律），就不要强行适配。
- 逻辑：此时，最安全的选择就是优雅地降级（Fallback），接受这个局部是“静态”的。
- DSL 输出: 在 DSL 中保留这些元素的绝对坐标信息，例如 { "position": "absolute", "x": 123, "y": 456 }。这为你后续的处理提供了一个“逃生出口”。
