# 产品需求文档提示词

现在我要做一个产品，将 sketch 的设计图转化成前端项目，步骤是：

1. 产品是基于 sketch 文件中的 page/xx.json 生成前端项目
2. 使用已经 filter（已有）方法，将多余字段过滤掉，并生成一个 filter.json
3. 基于一个工作流，将 filter.json 生成一个 json 格式的 dsl 文件
   其中工作流的作用：
4. 遍历整个 filter.json
5. 根据父子元素的关系，确定布局
6. 根据其中的样式描述字段，生成 style 信息
7. 区分常规元素和图片
8. 输出 json 格式 dsl 文件，文件大概格式为：

```json
{
    "element": "div",
    "style": {
        "display": "flex",
        ...
    }
    children: [
        {
            "element": "div",
            "style": {
                "justify-content": "center",
                ...
            }
        },
        {
            "element": "img",
            "src": 'xxx',
                        "style": {
                "justify-content": "center",
                ...
            }
        },
        ...
    ]
}
```

帮我理清思路，使用 markdown 生成一篇去需求文档

# 布局提示词

请根据下面的 Sketch page JSON，生成一个 HTML 文档，

```json
{
  "_class": "group",
  "name": "Page1",
  "rotation": 0,
  "frame": {
    "height": 1080,
    "width": 1920,
    "x": -453,
    "y": -107
  },
  "style": {
    "_class": "style"
  },
  "layers": [
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 178,
        "y": 182
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 743,
        "y": 182
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd 2",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 1308,
        "y": 182
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd 5",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 178,
        "y": 498
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd 6",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 178,
        "y": 814
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd 4",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 743,
        "y": 498
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62\u5907\u4efd 3",
      "rotation": 0,
      "frame": {
        "height": 210,
        "width": 434,
        "x": 1308,
        "y": 498
      },
      "style": {
        "_class": "style"
      }
    },
    {
      "_class": "rectangle",
      "name": "\u77e9\u5f62 2",
      "rotation": 0,
      "frame": {
        "height": 48,
        "width": 48,
        "x": 1768,
        "y": 46
      },
      "style": {
        "_class": "style"
      }
    }
  ]
}
```

要求：

1. 先分析父容器的宽高、子元素的宽高，以及子元素相对于父容器的 x/y 坐标，判断子元素在父容器中的分布特征：

   - 如果子元素在同一行且左右间距接近或对称，则推断为需要左右等距分布。
   - 如果子元素在同一列且上下间距接近或对称，则推断为需要上下等距分布。
   - 如果子元素排列规则更适合网格（例如多行多列），则优先使用 CSS Grid。
   - 如果子元素排列规则更线性（单行或单列），则优先使用 Flex。
   - 如果子元素间距不均匀，则允许通过 padding 或 margin 来还原。
   - 严格按照子元素的 x/y 坐标，来推断每个行列有多少个子元素来

2. 布局优先级：Grid ≥ Flex ＞ 其他。

3. 在绝大多数子元素都可以使用 响应式布局，但极少数元素异常的情况下，可以使用绝对定位

4. 在生成 CSS 时，不要简单使用 Sketch 的绝对 x/y 坐标，而是通过 **相对位置关系** 转换为：

   - grid-template-columns / grid-template-rows
   - justify-content / align-items
   - gap / margin / padding 等。

5. 需要保证响应式兼容（大屏/中屏/小屏）：

   - 可以用 `grid-template-columns: repeat(auto-fit, minmax(...))`
   - 或 `flex-wrap` 配合 `justify-content`。
   - 在小屏幕下自动换行或变为单列。

6. 目前提供的 Sketch page JSON，是基于 1920*1080 的屏幕设计的
7. 严格按照提供的 JSON 生成，不要添加任何不想干的元素
