# 布局分析规则（代码现状）

本文档详细说明了当前在 `converter/parsers/sketch/converter.py` 中实现的、用于分析设计图层布局的混合策略。**注意：此文档描述的是代码的当前行为，其中包含一些已知的逻辑缺陷。**

## 1. 规则优先策略

主要的布局引擎是 `_analyze_layout_with_rules` 函数。它处理父容器内的一组图层，并尝试在不咨询 LLM 的情况下识别布局模式。

### 1.1. 贪心迭代分组算法

当前算法采用一种贪心且迭代的方式来寻找独立的布局组，而非进行全局优化。

**工作流程如下：**

1.  **初始化**: 分析器接收一个同级图层列表，并将其放入一个“待处理”池中。
2.  **进入循环**: 只要“待处理”池中的图层多于一个，算法就会持续循环。
3.  **寻找最佳组**: 在**每一次**循环中，算法会遍历当前“待处理”池中的所有图层，分别找出满足对齐条件的**最长**的垂直列（`best_col`）和水平行（`best_row`）。
4.  **贪心决策**: 算法通过一个简单的长度比较（`len(best_col) >= len(best_row)`）来做出贪心选择。
    - 如果最长的列比最长的行更长或一样长，则优先采纳该列作为本次循环的唯一分组结果。
    - 否则，采纳行为分组。
5.  **锁定与移除**: 一旦做出选择，该组的成员图层就会被**立即**从“待处理”池中移除，并作为一个确定的布局组（e.g., `flex-column`）被记录下来。这个决策是**不可逆的**，在后续循环中不会被重新评估。
6.  **重复**: 算法在**缩减后**的“待处理”池上重复步骤 3-5，寻找下一个最突出的组。
7.  **结束**: 直到无法再形成任何长度大于1的组，循环结束。所有剩余的图层都被归类为**离群点 (outliers)**，并采用绝对定位。

> **缺陷分析**: 这种贪心机制是 `SKETCH-24` 等分组错误的根源。算法会因为某个方向的组数量更多而过早做出错误决策（例如，将属于水平行的图标“贪心”地捕获到更长的垂直列表中），并且没有有效的机制来推翻这个早期决策。

### 1.2. 分组检测逻辑

-   **列检测 (`flex-column`)**: 如果一组图层的 **x-坐标**标准差在 `LAYOUT_X_THRESHOLD` 阈值内，则视为对齐。
-   **行检测 (`flex-row`)**: 如果一组图层的 **y-坐标**标准差在 `LAYOUT_Y_THRESHOLD` 阈值内，则视为对齐。

### 1.3. 简化的 Gap 计算

一旦识别出 `flex` 组，其元素之间的 `gap` 就由 `_calculate_layout_properties` 函数通过一个简化的数学方法计算得出：

1.  该函数计算组内每个相邻项目之间的视觉距离，形成一个 `gaps` 列表。
2.  它直接使用 `statistics.mean()` 计算这个列表的**算术平均值**，并将结果四舍五入。

> **缺陷分析**: 这种方法对异常值（如设计稿中的微小错位）非常敏感。一个异常的间距会显著影响平均值，导致计算出的 `gap` 不准确。这是 `SKETCH-5` 缺陷的核心原因。

## 2. LLM 后备策略

仅在一种情况下会使用 LLM：

-   当 `_analyze_layout_with_rules` 函数处理一组图层后，**完全找不到任何 `flex` 或 `grid` 组**时。

在这种情况下，系统会回退到 `_analyze_layout_with_llm` 函数。

### 2.1. 混合 LLM 分析

即使在使用 LLM 时，系统也不完全信任其进行数学计算。过程如下：

1.  **LLM 负责分组**: 使用 `layout_grouping_prompt.md` 提示将图层发送给 LLM，该提示指示模型*仅*识别逻辑组（`flex`, `grid`）和离群点。
2.  **Python 负责计算**: LLM 提出的组随后被传递给同一个简化的 `_calculate_layout_properties` 函数来计算 `gap`（采用简单的平均值法）。

## 3. Virtual Group 生成机制

`Virtual Group`（虚拟组）的生成机制由 `_process_layout_analysis` 函数实现，其当前行为如下：

1.  **触发条件**: 当 `_analyze_layout_with_rules` 或 `_analyze_layout_with_llm` 成功识别出至少一个布局组时。
2.  **生成步骤**:
    *   为每个识别出的 `layout_group` 计算一个能完全包围其所有子图层的最小边界框。
    *   在 DSL 中创建一个新的 `div` 节点，并标记 `group_identifier` 为 `Virtual Group - <type>`。
    *   **关键**: 这个 `Virtual Group` 在其父容器中被赋予 `position: absolute` 绝对定位，其 `top` 和 `left` 值被设置为边界框的左上角坐标。
    *   原始的布局信息（如 `type: flex`, `direction: column`, `gap: ...`）被保留在 `Virtual Group` 的 `layout` 属性中。
    *   原分组内的所有子图层坐标被重新计算，以相对于其所属的 `Virtual Group` 定位。

## 4. (失效的) 分组冲突解决机制

代码中存在一个 `_resolve_group_conflicts` 函数，其意图是解决不同分组间的成员重叠问题。

> **缺陷分析**: 在当前的 `_analyze_layout_with_rules` 实现中，此函数被调用的时机是**在贪心迭代循环结束之后**。然而，贪心循环本身的设计（每次循环后都从池中移除已分组的图层）确保了最终产生的 `layout_groups` 列表是**互不重叠**的。因此，`_resolve_group_conflicts` 函数在被调用时，永远不会接收到任何有冲突的组，导致该功能**完全失效**，无法纠正任何分组错误。
