# 布局分析规则

本文档详细说明了用于分析和确定设计文件图层布局的混合策略。该系统优先采用快速、确定性的基于规则的方法，并仅在处理复杂情况时使用大型语言模型（LLM）作为后备。

## 1. 规则优先策略

主要的布局引擎是 `_analyze_layout_with_rules` 函数。它处理父容器内的一组图层，并尝试在不咨询 LLM 的情况下识别清晰的布局模式。

### 1.1. 迭代分组算法

分析器不是为所有图层假定单一布局，而是迭代地工作以找到多个独立的布局组。过程如下：

1.  分析器接收一个同级图层列表。
2.  它进入一个循环，尝试在剩余的图层中找到最突出的 `flex` 组（行或列）。
3.  如果识别出一个组（例如，一个清晰的垂直项目列表），这些图层将被捆绑到一个 `flex-column` 组中，并从待处理的图层列表中移除。
4.  循环在*剩余*的图层上重复，寻找下一个最明显的组（例如，水平的图标工具栏）。
5.  这个过程一直持续到无法形成更多清晰的组为止。
6.  任何剩余的图层都被归类为**离群点**，并采用绝对定位。

### 1.2. 分组检测逻辑

-   **列检测 (`flex-column`)**: 如果一组图层的 **x-坐标紧密对齐**，则将其识别为一列。对齐容差在 `converter/parsers/sketch/config.py` 中的 `LAYOUT_X_THRESHOLD` 定义。
-   **行检测 (`flex-row`)**: 如果一组图层的 **y-坐标紧密对齐**，则将其识别为一行。容差由 `LAYOUT_Y_THRESHOLD` 定义。

### 1.3. 阈值作用与调整

阈值用于定义"紧密对齐"的容差（tolerance），即允许的坐标偏差范围。如果图层的坐标差异小于阈值，就视为对齐，从而被分组。

-   **LAYOUT_X_THRESHOLD**：用于列检测（垂直组），检查 x-坐标偏差。默认值为5（像素），用于提高精度，避免错误地将不相关元素纳入垂直组。
-   **LAYOUT_Y_THRESHOLD**：用于行检测（水平组），检查 y-坐标偏差。默认值为5（像素），类似用于确保水平排列的元素被正确分组。

如果阈值过大，可能导致分组错误（如将水平元素纳入垂直组）；过小则可能无法检测到任何组，转而回退到 LLM。建议根据设计稿复杂度测试调整。

### 1.4. 确定性 Gap 计算

一旦识别出 `flex` 组，其元素之间的 `gap` 就由 `_calculate_layout_properties` 函数通过数学计算得出：

1.  该函数计算组内每个相邻项目之间的视觉距离。
2.  为确保对微小错位的鲁棒性，它首先计算所有检测到的 `gap` 的**中位数**。
3.  它会过滤掉任何与中位数偏差过大（超过50%）的 `gap` 值。
4.  最后，它计算过滤后 `gap` 的**平均值**并四舍五入为最接近的整数。

这种确定性的方法确保了 `gap` 值的一致性和准确性，从而修复了 SKETCH-5 错误的核心问题。

### 1.5. 规则检测示例

假设有一个设计稿包含第一排6个正方形（y坐标对齐）和下面的垂直长方形列表（x坐标对齐）：
-   算法先检测最佳列（垂直组）：可能找到长方形列表（x偏差 < LAYOUT_X_THRESHOLD=5）。
-   然后检测最佳行（水平组）：找到正方形一行（y偏差 < LAYOUT_Y_THRESHOLD=5）。
-   比较大小：如果列更大，先分组列；否则分组行。
-   剩余图层重复过程。

如果发生分组错误（如第一个正方形被纳入垂直组），后续的冲突解决机制（见第4节）会介入。

## 2. LLM 后备策略

仅在一种情况下会使用 LLM：

-   当 `_analyze_layout_with_rules` 函数处理一组图层后，**完全找不到任何 `flex` 或 `grid` 组**时。

在这种情况下，系统会回退到 `_analyze_layout_with_llm` 函数。

### 2.1. 混合 LLM 分析

即使在使用 LLM 时，系统也不信任其进行数学计算。过程如下：

1.  **LLM 负责分组**: 使用 `layout_grouping_prompt.md` 提示将图层发送给 LLM，该提示指示模型*仅*识别逻辑组（`flex`, `grid`）和离群点。
2.  **Python 负责计算**: LLM 提出的组随后被传递给同一个确定性的 `_calculate_layout_properties` 函数来计算 `gap`。

这种混合方法确保了即使在复杂的、模棱两可的布局中，最终的 `gap` 值也能由 Python 代码准确可靠地计算出来。

### 2.2. LLM 后备示例

如果规则无法分组（如图层坐标偏差超过阈值5），LLM 会收到简化后的图层数据（name, class, frame），并输出 JSON 如：
```json
{
  "layout_groups": [
    { "type": "flex", "direction": "row", "children_indices": [0,1,2] }
  ],
  "outlier_indices": [3,4]
}
```
然后 Python 计算 gap 等属性。

## 3. Virtual Group 生成机制

`Virtual Group`（虚拟组）是在 DSL（领域特定语言）中创建的一个合成概念，它在原始的设计稿中并不直接存在。它的主要目的是将分析器（无论是基于规则还是基于 LLM）识别出的、具有内在布局关系（如 `flex` 或 `grid`）的一组图层，封装在一个可定位的容器中。

该机制由 `_process_layout_analysis` 函数实现。

### 3.1. 触发条件

当 `_analyze_layout_with_rules` 或 `_analyze_layout_with_llm` 成功识别出至少一个布局组（`layout_groups`）时，就会触发 `Virtual Group` 的生成流程。

### 3.2. 生成步骤

1.  **遍历分组**: 程序会遍历分析结果中的每一个 `layout_group`。
2.  **计算边界框**: 对于每个组，程序会计算一个能完全包围其所有子图层的最小边界框（Bounding Box），得出其 `min_x`, `min_y`, `max_x`, `max_y`。
3.  **创建虚拟组**:
    *   在 DSL 中创建一个新的 `div` 节点，并为其添加一个 `group_identifier` 字段，其值被设为 `Virtual Group - <type>`（例如，`Virtual Group - flex`）。这个字段用于在 DSL 层面清晰地标识该节点的来源。
    *   这个 `Virtual Group` 的尺寸（`width`, `height`）由上一步计算出的边界框决定。
    *   **关键：** 这个 `Virtual Group` 在其父容器中被赋予 `position: absolute` 绝对定位，其 `top` 和 `left` 值被设置为边界框的 `min_y` 和 `min_x`。
4.  **保留内部布局**:
    *   原始的、由分析器识别出的布局信息（例如 `type: flex`, `direction: column`, `gap: 51`）被完整地保留在 `Virtual Group` 的 `layout` 属性中。
    *   这就在一个绝对定位的容器内部，创建了一个相对布局（`flex` 或 `grid`）的上下文。
5.  **坐标调整**: 原分组内的所有子图层，其坐标会被重新计算，以使其相对于 `Virtual Group` 的左上角进行定位。

### 3.3. 目的与效果

这种机制的目的是在保持页面整体布局（通过绝对定位的虚拟组）的同时，保留局部区域（虚拟组内部）的响应式布局能力。例如，一个垂直列表（`flex-column`）作为一个整体，它在页面上的位置是固定的，但列表内部的项目则可以根据 `flex` 布局的规则进行排列和响应。

此外，为了便于前端调试，在最终生成代码时，`group_identifier` 的值会被渲染为 HTML 元素的 `data-group-identifier` 属性。这使得开发者可以在浏览器中直接看到由布局引擎创建的虚拟容器。

## 4. 分组冲突解决机制

在迭代分组后，可能出现组间冲突（如一个图层被多个组"争夺"，例如同时满足行和列对齐条件）。为此，系统引入了 `_resolve_group_conflicts` 函数，在 `_analyze_layout_with_rules` 的末尾调用。

### 4.1. 触发条件

-   当检测到多个组的 `children_indices` 重叠时（即同一图层被分配到不同组）。

### 4.2. 解决步骤

1.  **排序组**：按组大小（children_indices 长度）降序排序，优先处理大组。
2.  **检查冲突**：对于每个组，检查其索引是否与已解析组重叠。
3.  **计算对齐强度**：使用 `statistics.variance` 计算坐标方差（越小表示对齐越强）：
    - 对于 `row` 组：计算 y-坐标方差。
    - 对于 `column` 组：计算 x-坐标方差。
4.  **决策**：如果当前组的方差 < 阈值（默认25），则覆盖冲突部分（移除旧组，添加新组）。
5.  **更新**：维护已解析索引集，避免重复。

### 4.3. 目的与效果

这确保了更强的对齐组（如方差小的水平行）优先于弱组，避免错误分组（如用户提到的 bug：第一个正方形被垂直组吞并）。阈值25是经验值，可根据测试调整。

### 4.4. 示例

假设检测到垂直组（方差=30）和水平组（方差=10，重叠一个元素）：
-   如果水平组方差 < 25，则保留水平组，移除垂直组中的冲突元素。

## 5. 测试与调试指南

-   **测试方法**：使用 `verify_sketch_5.py` 脚本运行转换任务，检查生成的 dsl.json 中的 `layout_groups` 是否正确（e.g., group_identifier 和 children_indices）。
-   **常见问题**：
    -   分组错误：调整阈值（LAYOUT_X/Y_THRESHOLD）或检查坐标数据。
    -   LLM 失败：确保 LLM 服务可用（API_KEY 和 BASE_URL）。
    -   冲突未解决：调低冲突阈值（e.g., 从25到10）。
-   **调试提示**：在函数中添加 logger.info 输出 layout_groups 前后变化；使用浏览器检查 data-group-identifier 属性验证 Virtual Group。