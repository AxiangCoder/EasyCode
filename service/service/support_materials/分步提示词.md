
# 专家级提示词

## 提示词 1：重构“设计工具到 DSL”的解析器架构

**角色**: 你是一位资深的 Python/Django 软件架构师，精通使用设计模式（如策略模式、工厂模式）构建可扩展、可维护的系统。

**目标**: 重构现有的 `converter` 应用，解耦 `DesignConverterService` 与具体的 `SketchConverter`，建立一个可插拔的解析器架构，为未来支持 Figma、Adobe XD 等多种设计工具奠定基础。

**上下文**:
当前系统通过 `DesignConverterService` 直接调用 `SketchConverter` 来处理上传的 Sketch JSON 文件。这种紧耦合的设计不利于扩展。你需要将其重构为一个灵活的、基于策略模式的解析器（Parser）架构。

**详细执行步骤**:

1.  **增强数据模型 (`converter/models.py`)**:
    *   定位到 `ConversionTask` 模型。
    *   增加一个 `source_type` 字段：`models.CharField`，包含 `choices` 如 `('sketch', 'Sketch')`, `('figma', 'Figma')`，并设一个默认值。
    *   增加一个 `source_url` 字段：`models.URLField(blank=True, null=True)`，用于存储在线设计工具的 URL。
    *   修改现有的 `input_file` 字段，使其也允许为空：`blank=True, null=True`。
    *   在 `serializers.py` 中添加验证逻辑，确保当 `source_type` 为 `sketch` 时 `input_file` 存在，当为 `figma` 时 `source_url` 存在。

2.  **创建解析器目录结构**:
    *   在 `converter/` 目录下创建一个新的包 `parsers/`。
    *   将现有的 `converter/sketch_converter/` 整个目录移动到 `converter/parsers/sketch/`。

3.  **定义抽象解析器接口 (`converter/parsers/base.py`)**:
    *   创建一个新文件 `base.py`。
    *   在其中定义一个抽象基类 `BaseParser(ABC)`。
    *   `__init__` 方法应接收 `source_data` (已加载的 Python 字典或数据流) 和 `tokens_data` 作为输入，而不是文件路径。
    *   定义一个静态方法 `@staticmethod def count_nodes(source_data: dict) -> int:`。此方法用于在主转换开始前，快速遍历源数据以获取节点总数，为实时进度计算提供支持。
    *   定义一个抽象方法 `@abstractmethod def run(self) -> tuple:`，它必须返回一个元组 `(dsl_dict, metadata_dict)`。`dsl_dict` 是标准化的 DSL 输出，`metadata_dict` 包含 Token 报告等次要信息。

4.  **重构 `SketchParser` (`converter/parsers/sketch/converter.py`)**:
    *   使其继承自 `BaseParser`。
    *   实现 `@staticmethod def count_nodes(source_data: dict) -> int:`，其逻辑可从旧的 `sum_nodes` 工具函数迁移而来。
    *   修改 `__init__` 方法，使其接收 `source_data`。
    *   重构 `run` 方法：移除所有内部的文件读写逻辑。它现在应该直接处理 `self.source_data`，并返回 DSL 字典和包含 Token 报告的元数据字典。

5.  **创建解析器工厂 (`converter/parsers/__init__.py`)**:
    *   创建一个工厂函数 `get_parser_class(source_type: str) -> type[BaseParser]:`。
    *   此函数根据 `source_type` 返回对应的**解析器类**（例如 `SketchParser`），而不是实例。如果类型不支持，则抛出异常。

6.  **重构核心服务 (`converter/service/design_converter_service.py`)**:
    *   `DesignConverterService` 的职责是**编排完整的解析流程**，包括 I/O 和两步转换。
    *   修改 `convert_design_file` 方法，使其接收一个 `ConversionTask` 实例。
    *   **实现转换全流程**:
        1.  **预计算**: 根据 `task.source_type` 获取 `source_data`（读文件或请求 API）。调用 `parsers.get_parser_class()` 工厂获取解析器**类**。调用 `ParserClass.count_nodes(source_data)` 得到节点总数。**立即更新并保存 `task.input_nodes` 字段**。这是确保进度条能正确工作的关键。
        2.  **执行转换**: 实例化解析器 `parser = ParserClass(source_data, ...)`。调用 `parser.run()` 方法（并传入 `progress_callback`），获取 `dsl` 和 `metadata`。
        3.  **生成预览**: 在获得 `dsl` 后，调用一个工具函数（例如 `converter.utils.generate_html_from_dsl(dsl)`）来生成一份用于快速预览的 HTML 字符串。
        4.  **保存结果**: 创建 `ConversionResult` 实例时，将 `dsl`、`metadata` 中的信息（如 token 报告）以及上一步生成的 `html_preview` 字符串完整地存入数据库对应的字段中。

7.  **简化异步任务 (`converter/tasks.py`)**:
    *   移除 `convert_design_file_task` 中关于 `sum_nodes` 的预处理逻辑。
    *   `progress_callback` 函数本身几乎无需改动。因为它在被调用时，`DesignConverterService` 已经在上一步中将正确的 `input_nodes` 总数存入了数据库，使其能够继续正确地计算进度百分比。

---

## 提示词 2：实现“DSL 到前端代码”的渲染器

**角色**: 你是一位顶级的全栈软件工程师，对使用 Python/Django 构建后端服务、代码生成技术以及使用 React/Vite/TailwindCSS 构建现代前端应用有非常深入的理解。

**目标**: 根据项目规划文档 `support_materials/dsl_pipeline_status.md`，实现一个功能完整的“DSL 到前端代码”渲染管道。

**上下文**:
系统已经可以通过第一阶段的解析器生成一份标准化的 DSL JSON，并存储在 `ConversionResult` 模型中。现在，你需要实现第二阶段，将这份 DSL 渲染成一个完整的、可运行的 Vite + React + Antd + Tailwind CSS 前端项目。

**详细执行步骤**:

1.  **创建渲染器模块结构 (`converter/frontend_renderer/`)**:
    *   严格按照 `dsl_pipeline_status.md` 中“模块划分”一节的规划，创建 `frontend_renderer` 包。
    *   **`__init__.py`**: 实现对外暴露的主入口函数 `render_project(dsl: dict, options: dict) -> list[FileArtifact]`，其中 `FileArtifact` 是一个包含路径和内容的数据类。
    *   **`context.py`**: 实现 `RenderContext` 类，用于在渲染过程中全局管理状态，如组件映射表、Tailwind 类、自定义 CSS、依赖导入列表等。
    *   **`component_map.py`**: 实现从外部 JSON 文件（例如 `component-map.json`）加载“语义标记 → Antd 组件”映射表的逻辑。
    *   **`page_renderer.py` 和 `component_renderer.py`**:
        *   使用 `jinja2` 作为模板引擎。
        *   实现递归遍历 DSL 树的逻辑。
        *   根据节点的 `semanticType` 在组件映射表中查找对应的 Antd 组件，并渲染成 TSX 字符串。
        *   如果 `semanticType` 缺失，则降级为 `div` 并添加 `// TODO:` 注释。
    *   **`style_mapper.py`**:
        *   实现 `StyleEngine` 抽象基类和 `TailwindEngine` 具体实现。
        *   负责将 DSL 中的 `style` 对象转换为 Tailwind CSS 类名。
        *   对于无法转换的样式，收集起来生成自定义 CSS。
    *   **`template_writer.py`**: 实现文件写入逻辑，包括复制基础模板和写入新生成的文件。

2.  **创建前端项目模板**:
    *   在 `converter/` 下创建 `project_templates/vite-react-ts-antd-tailwind/` 目录。
    *   在其中放置一个最小化的 Vite + React + TS 项目骨架，包含 `package.json` (声明 antd, tailwindcss 等依赖)、`vite.config.ts`, `tailwind.config.js`, `postcss.config.js` 以及 `src/` 目录结构。

3.  **实现新的渲染服务 (`converter/service/frontend_generation_service.py`)**:
    *   创建一个全新的服务类 `FrontendGenerationService`。
    *   定义核心方法 `generate_project(conversion_result_id: str, options: dict) -> str:`，返回最终产物（如 zip 文件）的路径。
    *   **编排逻辑**:
        1.  根据 `conversion_result_id` 从数据库加载 DSL JSON。
        2.  调用 `frontend_renderer.render_project()`，获取内存中的文件列表 `[FileArtifact]`。
        3.  创建一个临时目录，将基础模板和生成的文件写入其中。
        4.  在临时目录中，通过 `subprocess` 执行 `npm install` 和 `npm run build` 来验证项目的可构建性。
        5.  将整个临时目录打包成一个 zip 压缩文件。
        6.  返回 zip 文件的路径。

4.  **创建新的异步任务 (`converter/tasks.py`)**:
    *   添加一个新的 Celery 任务 `generate_frontend_project_task(result_id, options)`。
    *   该任务的核心就是调用 `FrontendGenerationService` 的 `generate_project` 方法。

5.  **在 API 层暴露入口 (`converter/views.py`)**:
    *   在 `ConversionResultViewSet` 中，添加一个新的 `@action`，例如 `generate_project`。
    *   这个 action 接收前端框架、样式方案等作为 `options`。
    *   它会触发 `generate_frontend_project_task` 异步任务，并立即返回一个任务 ID，前端可以通过这个 ID 轮询生成状态和最终的下载链接。
